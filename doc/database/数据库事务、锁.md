# 数据库事务与锁

## 四种隔离级别

### Read Uncommitted(读取未提交内容)

**基本概念**

    如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据，即所有事务都可以看到其他未提交事务的执行结果，该隔离级别可以通过“排他写锁”实现

**存在问题** 
    
    避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。

### Read Committed(读取提交内容)

**基本概念**

    读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行，即一个事务只能看见已提交事务所做的改变

**存在问题**

    该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变

### Repeatable Read(可重读)

**基本概念**

    读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。它确保同一事务的多个实例在并发读取数据时，会看到相同的数据行。

**存在问题**

    避免了不可重复读取和脏读，但是有时可能出现幻读。这可以通过“共享读锁”和“排他写锁”实现。

### Serializable(可串行化)

**基本概念**

    提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。

**存在问题**

    序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，可能导致大量的超时现象和锁竞争。

## 总结：

    隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制

|   隔离级别|   脏读| 不可重复读|  幻读|     对应封锁协议|
|    -     |   :-: |    :-:   |:-:   |      -         |
|读未提交(Read Uncommitted) |X|X|X|**一级封锁协议:** 事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）|
|读已提交(Read Committed)   |O|X|X|**二级封锁协议:** 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁（瞬间S锁）。|
|可重复读(Repeatable Read)  |O|O|X|**三级封锁协议:** 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。|
|可串行化(Serializable)     |O|O|O|**四级封锁协议** 是对三级封锁协议的增强，其实现机制也最为简单，直接对 事务中 所 读取 或者 更改的数据所在的表加表锁，也就是说，其他事务不能 读写 该表中的任何数据。这样五类并发问题都得以避免|
>注：封锁协议和隔离级别并不是严格对应的
